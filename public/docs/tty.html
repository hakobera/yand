<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE html>
<html lang="en"><body class="alt apidoc" id="api-section-tty">
    
    <div id="content" class="clearfix">
        

        <div id="column1" class="interior">
          

          <div id="apicontent">
            <h1 id="tty_tty">TTY<span><a class="mark" href="#tty_tty" id=""/></span></h1>
<pre><code>Stability: 2 - Unstable</code></pre>
<p>The <code>tty</code> module houses the <code>tty.ReadStream</code> and <code>tty.WriteStream</code> classes. In
most cases, you will not need to use this module directly.

</p>
<p>When node detects that it is being run inside a TTY context, then <code>process.stdin</code>
will be a <code>tty.ReadStream</code> instance and <code>process.stdout</code> will be
a <code>tty.WriteStream</code> instance. The preferred way to check if node is being run in
a TTY context is to check <code>process.stdout.isTTY</code>:

</p>
<pre><code>$ node -p -e "Boolean(process.stdout.isTTY)"
true
$ node -p -e "Boolean(process.stdout.isTTY)" | cat
false</code></pre>
<h2 id="tty_tty_isatty_fd">tty.isatty(fd)<span><a class="mark" href="#tty_tty_isatty_fd" id=""/></span></h2>
<p>Returns <code>true</code> or <code>false</code> depending on if the <code>fd</code> is associated with a
terminal.


</p>
<h2 id="tty_tty_setrawmode_mode">tty.setRawMode(mode)<span><a class="mark" href="#tty_tty_setrawmode_mode" id=""/></span></h2>
<p>Deprecated. Use <code>tty.ReadStream#setRawMode()</code>
(i.e. <code>process.stdin.setRawMode()</code>) instead.


</p>
<h2 id="tty_class_readstream">Class: ReadStream<span><a class="mark" href="#tty_class_readstream" id=""/></span></h2>
<p>A <code>net.Socket</code> subclass that represents the readable portion of a tty. In normal
circumstances, <code>process.stdin</code> will be the only <code>tty.ReadStream</code> instance in any
node program (only when <code>isatty(0)</code> is true).

</p>
<h3 id="tty_rs_israw">rs.isRaw<span><a class="mark" href="#tty_rs_israw" id=""/></span></h3>
<p>A <code>Boolean</code> that is initialized to <code>false</code>. It represents the current "raw" state
of the <code>tty.ReadStream</code> instance.

</p>
<h3 id="tty_rs_setrawmode_mode">rs.setRawMode(mode)<span><a class="mark" href="#tty_rs_setrawmode_mode" id=""/></span></h3>
<p><code>mode</code> should be <code>true</code> or <code>false</code>. This sets the properties of the
<code>tty.ReadStream</code> to act either as a raw device or default. <code>isRaw</code> will be set
to the resulting mode.


</p>
<h2 id="tty_class_writestream">Class WriteStream<span><a class="mark" href="#tty_class_writestream" id=""/></span></h2>
<p>A <code>net.Socket</code> subclass that represents the writable portion of a tty. In normal
circumstances, <code>process.stdout</code> will be the only <code>tty.WriteStream</code> instance
ever created (and only when <code>isatty(1)</code> is true).

</p>
<h3 id="tty_ws_columns">ws.columns<span><a class="mark" href="#tty_ws_columns" id=""/></span></h3>
<p>A <code>Number</code> that gives the number of columns the TTY currently has. This property
gets updated on "resize" events.

</p>
<h3 id="tty_ws_rows">ws.rows<span><a class="mark" href="#tty_ws_rows" id=""/></span></h3>
<p>A <code>Number</code> that gives the number of rows the TTY currently has. This property
gets updated on "resize" events.

</p>
<h3 id="tty_event_resize">Event: 'resize'<span><a class="mark" href="#tty_event_resize" id=""/></span></h3>
<p><code>function () {}</code>

</p>
<p>Emitted by <code>refreshSize()</code> when either of the <code>columns</code> or <code>rows</code> properties
has changed.

</p>
<pre><code>process.stdout.on('resize', function() {
  console.log('screen size has changed!');
  console.log(process.stdout.columns + 'x' + process.stdout.rows);
});</code></pre>

          </div>
        </div>
    </div>
    

  </body></html>
